//! Optimization passes for the Augustium compiler
//!
//! This module implements various optimization techniques to improve
//! gas efficiency and performance of generated bytecode.

use crate::ast::*;
use crate::codegen::{Instruction, Bytecode};
use crate::error::{Result, CodegenError, CodegenErrorKind, SourceLocation};
use std::collections::HashSet;

/// Optimization error
#[derive(Debug, Clone)]
pub struct OptimizationError {
    pub message: String,
    pub location: SourceLocation,
}

impl From<OptimizationError> for crate::error::CompilerError {
    fn from(err: OptimizationError) -> Self {
        crate::error::CompilerError::CodegenError(CodegenError {
            kind: CodegenErrorKind::OptimizationFailed,
            location: err.location,
            message: err.message,
        })
    }
}

/// Trait for optimization passes
pub trait OptimizationPass {
    fn run(&self, ast: &mut SourceFile) -> Result<()>;
    #[allow(dead_code)]
    fn name(&self) -> &str;
}

/// Bytecode optimization trait
pub trait BytecodeOptimizationPass {
    fn run(&self, bytecode: &mut Bytecode) -> Result<()>;
    #[allow(dead_code)]
    fn name(&self) -> &str;
}

/// Main optimizer that runs multiple passes
pub struct Optimizer {
    passes: Vec<Box<dyn OptimizationPass>>,
    bytecode_passes: Vec<Box<dyn BytecodeOptimizationPass>>,
}

impl Optimizer {
    pub fn new() -> Self {
        let mut optimizer = Self {
            passes: Vec::new(),
            bytecode_passes: Vec::new(),
        };
        
        // Add default optimization passes
        optimizer.add_pass(Box::new(DeadCodeElimination::new()));
        optimizer.add_pass(Box::new(ConstantFolding::new()));
        optimizer.add_pass(Box::new(GasOptimization::new()));
        
        // Add bytecode optimization passes
        optimizer.add_bytecode_pass(Box::new(PeepholeOptimization::new()));
        optimizer.add_bytecode_pass(Box::new(RedundantInstructionElimination::new()));
        
        optimizer
    }
    
    pub fn add_pass(&mut self, pass: Box<dyn OptimizationPass>) {
        self.passes.push(pass);
    }
    
    pub fn add_bytecode_pass(&mut self, pass: Box<dyn BytecodeOptimizationPass>) {
        self.bytecode_passes.push(pass);
    }
    
    /// Run all AST optimization passes
    pub fn optimize_ast(&self, ast: &mut SourceFile) -> Result<()> {
        for pass in &self.passes {
            pass.run(ast)?;
        }
        Ok(())
    }
    
    /// Run all bytecode optimization passes
    pub fn optimize_bytecode(&self, bytecode: &mut Bytecode) -> Result<()> {
        for pass in &self.bytecode_passes {
            pass.run(bytecode)?;
        }
        Ok(())
    }
}

/// Dead code elimination pass
pub struct DeadCodeElimination {
    used_functions: HashSet<String>,
    used_variables: HashSet<String>,
}

impl DeadCodeElimination {
    pub fn new() -> Self {
        Self {
            used_functions: HashSet::new(),
            used_variables: HashSet::new(),
        }
    }
    
    fn mark_used_symbols(&mut self, ast: &SourceFile) {
        // Mark entry points as used
        for item in &ast.items {
            match item {
                Item::Function(func) => {
                    // Mark main functions and public functions as used
                    if func.name.name == "main" || func.visibility == Visibility::Public {
                        self.used_functions.insert(func.name.name.clone());
                        self.mark_function_dependencies(func);
                    }
                }
                Item::Contract(contract) => {
                    // All contract functions are potentially callable
                    for func in &contract.functions {
                        self.used_functions.insert(func.name.name.clone());
                        self.mark_function_dependencies(func);
                    }
                }
                _ => {}
            }
        }
    }
    
    fn mark_function_dependencies(&mut self, function: &Function) {
        self.mark_block_dependencies(&function.body);
    }
    
    fn mark_block_dependencies(&mut self, block: &Block) {
        for stmt in &block.statements {
            self.mark_statement_dependencies(stmt);
        }
    }
    
    fn mark_statement_dependencies(&mut self, stmt: &Statement) {
        match stmt {
            Statement::Expression(expr) => self.mark_expression_dependencies(expr),
            Statement::Let(let_stmt) => {
                self.used_variables.insert(let_stmt.name.name.clone());
                if let Some(init) = &let_stmt.value {
                    self.mark_expression_dependencies(init);
                }
            }
            Statement::Return(ret_stmt) => {
                if let Some(expr) = &ret_stmt.value {
                    self.mark_expression_dependencies(expr);
                }
            }
            Statement::If(if_stmt) => {
                    self.mark_expression_dependencies(&if_stmt.condition);
                    self.mark_block_dependencies(&if_stmt.then_block);
                    if let Some(else_stmt) = &if_stmt.else_block {
                        self.mark_statement_dependencies(else_stmt);
                    }
                }
            Statement::While(while_stmt) => {
                self.mark_expression_dependencies(&while_stmt.condition);
                self.mark_block_dependencies(&while_stmt.body);
            }
            Statement::For(for_stmt) => {
                    self.mark_expression_dependencies(&for_stmt.iterable);
                    self.mark_block_dependencies(&for_stmt.body);
                }
            _ => {}
        }
    }
    
    fn mark_expression_dependencies(&mut self, expr: &Expression) {
        match expr {
            Expression::Identifier(ident) => {
                self.used_variables.insert(ident.name.clone());
            }
            Expression::Call(call) => {
                if let Expression::Identifier(func_name) = &*call.function {
                    self.used_functions.insert(func_name.name.clone());
                }
                self.mark_expression_dependencies(&call.function);
                for arg in &call.arguments {
                    self.mark_expression_dependencies(arg);
                }
            }
            Expression::Binary(binary) => {
                self.mark_expression_dependencies(&binary.left);
                self.mark_expression_dependencies(&binary.right);
            }
            Expression::Unary(unary) => {
                self.mark_expression_dependencies(&unary.operand);
            }
            Expression::FieldAccess(field) => {
                self.mark_expression_dependencies(&field.object);
            }
            Expression::Index(index) => {
                self.mark_expression_dependencies(&index.object);
                self.mark_expression_dependencies(&index.index);
            }
            Expression::Assignment(assign) => {
                self.mark_expression_dependencies(&assign.target);
                self.mark_expression_dependencies(&assign.value);
            }
            _ => {}
        }
    }
    
    fn remove_unused_items(&self, ast: &mut SourceFile) {
        ast.items.retain(|item| {
            match item {
                Item::Function(func) => {
                    self.used_functions.contains(&func.name.name)
                }
                Item::Const(const_decl) => {
                    self.used_variables.contains(&const_decl.name.name)
                }
                // Keep contracts, structs, enums, traits, and impls
                _ => true,
            }
        });
    }
}

impl OptimizationPass for DeadCodeElimination {
    fn run(&self, ast: &mut SourceFile) -> Result<()> {
        let mut pass = DeadCodeElimination::new();
        pass.mark_used_symbols(ast);
        pass.remove_unused_items(ast);
        Ok(())
    }
    
    fn name(&self) -> &str {
        "Dead Code Elimination"
    }
}

/// Constant folding optimization pass
pub struct ConstantFolding;

impl ConstantFolding {
    pub fn new() -> Self {
        Self
    }
    
    fn fold_expression(&self, expr: &mut Expression) -> Result<()> {
        match expr {
            Expression::Binary(binary) => {
                self.fold_expression(&mut binary.left)?;
                self.fold_expression(&mut binary.right)?;
                
                // Try to fold constant binary operations
                if let (Expression::Literal(left_lit), Expression::Literal(right_lit)) = 
                    (&*binary.left, &*binary.right) {
                    if let Some(result) = self.fold_binary_literals(&binary.operator, left_lit, right_lit)? {
                        *expr = Expression::Literal(result);
                    }
                }
            }
            Expression::Unary(unary) => {
                self.fold_expression(&mut unary.operand)?;
                
                // Try to fold constant unary operations
                if let Expression::Literal(lit) = &*unary.operand {
                    if let Some(result) = self.fold_unary_literal(&unary.operator, lit)? {
                        *expr = Expression::Literal(result);
                    }
                }
            }
            Expression::Call(call) => {
                self.fold_expression(&mut call.function)?;
                for arg in &mut call.arguments {
                    self.fold_expression(arg)?;
                }
            }
            Expression::FieldAccess(field) => {
                self.fold_expression(&mut field.object)?;
            }
            Expression::Index(index) => {
                self.fold_expression(&mut index.object)?;
                self.fold_expression(&mut index.index)?;
            }
            Expression::Assignment(assign) => {
                self.fold_expression(&mut assign.target)?;
                self.fold_expression(&mut assign.value)?;
            }
            _ => {}
        }
        Ok(())
    }
    
    fn fold_binary_literals(&self, op: &BinaryOperator, left: &Literal, right: &Literal) -> Result<Option<Literal>> {
        match (left, right) {
            (Literal::Integer(a), Literal::Integer(b)) => {
                let result = match op {
                    BinaryOperator::Add => a.checked_add(*b),
                    BinaryOperator::Subtract => a.checked_sub(*b),
                    BinaryOperator::Multiply => a.checked_mul(*b),
                    BinaryOperator::Divide => {
                        if *b == 0 {
                            return Ok(None); // Don't fold division by zero
                        }
                        a.checked_div(*b)
                    }
                    BinaryOperator::Modulo => {
                        if *b == 0 {
                            return Ok(None); // Don't fold modulo by zero
                        }
                        a.checked_rem(*b)
                    }
                    BinaryOperator::Equal => return Ok(Some(Literal::Boolean(a == b))),
                    BinaryOperator::NotEqual => return Ok(Some(Literal::Boolean(a != b))),
                    BinaryOperator::Less => return Ok(Some(Literal::Boolean(a < b))),
                    BinaryOperator::LessEqual => return Ok(Some(Literal::Boolean(a <= b))),
                    BinaryOperator::Greater => return Ok(Some(Literal::Boolean(a > b))),
                    BinaryOperator::GreaterEqual => return Ok(Some(Literal::Boolean(a >= b))),
                    _ => None,
                };
                Ok(result.map(Literal::Integer))
            }
            (Literal::Float(a), Literal::Float(b)) => {
                let result = match op {
                    BinaryOperator::Add => Some(*a + *b),
                    BinaryOperator::Subtract => Some(*a - *b),
                    BinaryOperator::Multiply => Some(*a * *b),
                    BinaryOperator::Divide => {
                        if *b == 0.0 {
                            return Ok(None); // Don't fold division by zero
                        }
                        Some(*a / *b)
                    }
                    BinaryOperator::Equal => return Ok(Some(Literal::Boolean(a == b))),
                    BinaryOperator::NotEqual => return Ok(Some(Literal::Boolean(a != b))),
                    BinaryOperator::Less => return Ok(Some(Literal::Boolean(a < b))),
                    BinaryOperator::LessEqual => return Ok(Some(Literal::Boolean(a <= b))),
                    BinaryOperator::Greater => return Ok(Some(Literal::Boolean(a > b))),
                    BinaryOperator::GreaterEqual => return Ok(Some(Literal::Boolean(a >= b))),
                    _ => None,
                };
                Ok(result.map(Literal::Float))
            }
            (Literal::Boolean(a), Literal::Boolean(b)) => {
                let result = match op {
                    BinaryOperator::And => *a && *b,
                    BinaryOperator::Or => *a || *b,
                    BinaryOperator::Equal => *a == *b,
                    BinaryOperator::NotEqual => *a != *b,
                    _ => return Ok(None),
                };
                Ok(Some(Literal::Boolean(result)))
            }
            _ => Ok(None),
        }
    }
    
    fn fold_unary_literal(&self, op: &UnaryOperator, operand: &Literal) -> Result<Option<Literal>> {
        match (op, operand) {
            (UnaryOperator::Minus, Literal::Integer(n)) => {
                Ok(n.checked_neg().map(Literal::Integer))
            }
            (UnaryOperator::Minus, Literal::Float(f)) => {
                Ok(Some(Literal::Float(-f)))
            }
            (UnaryOperator::Not, Literal::Boolean(b)) => {
                Ok(Some(Literal::Boolean(!b)))
            }
            _ => Ok(None),
        }
    }
    
    fn fold_statements(&self, statements: &mut Vec<Statement>) -> Result<()> {
        for stmt in statements {
            match stmt {
                Statement::Expression(expr) => {
                    self.fold_expression(expr)?;
                }
                Statement::Let(let_stmt) => {
                    if let Some(init) = &mut let_stmt.value {
                        self.fold_expression(init)?;
                    }
                }
                Statement::Return(ret_stmt) => {
                    if let Some(expr) = &mut ret_stmt.value {
                        self.fold_expression(expr)?;
                    }
                }
                Statement::If(if_stmt) => {
                    self.fold_expression(&mut if_stmt.condition)?;
                    self.fold_statements(&mut if_stmt.then_block.statements)?;
                    if let Some(else_stmt) = &mut if_stmt.else_block {
                        match &mut **else_stmt {
                            Statement::If(nested_if) => {
                                self.fold_expression(&mut nested_if.condition)?;
                                self.fold_statements(&mut nested_if.then_block.statements)?;
                            }
                            _ => {}
                        }
                    }
                }
                Statement::While(while_stmt) => {
                    self.fold_expression(&mut while_stmt.condition)?;
                    self.fold_statements(&mut while_stmt.body.statements)?;
                }
                Statement::For(for_stmt) => {
                    self.fold_expression(&mut for_stmt.iterable)?;
                    self.fold_statements(&mut for_stmt.body.statements)?;
                }
                _ => {}
            }
        }
        Ok(())
    }
}

impl OptimizationPass for ConstantFolding {
    fn run(&self, ast: &mut SourceFile) -> Result<()> {
        for item in &mut ast.items {
            match item {
                Item::Function(func) => {
                    self.fold_statements(&mut func.body.statements)?;
                }
                Item::Contract(contract) => {
                    for func in &mut contract.functions {
                        self.fold_statements(&mut func.body.statements)?;
                    }
                }
                Item::Impl(impl_block) => {
                    for func in &mut impl_block.functions {
                        self.fold_statements(&mut func.body.statements)?;
                    }
                }
                _ => {}
            }
        }
        Ok(())
    }
    
    fn name(&self) -> &str {
        "Constant Folding"
    }
}

/// Gas optimization pass
pub struct GasOptimization;

impl GasOptimization {
    pub fn new() -> Self {
        Self
    }
    
    /// Optimize storage layout for gas efficiency
    fn optimize_storage_layout(&self, ast: &mut SourceFile) -> Result<()> {
        // Implement storage layout optimization
        for item in &mut ast.items {
            if let Item::Contract(contract) = item {
                self.optimize_contract_storage(contract)?;
            } else if let Item::Struct(struct_def) = item {
                self.optimize_struct_storage(struct_def)?;
            }
        }
        Ok(())
    }

    /// Optimize contract storage layout
    fn optimize_contract_storage(&self, contract: &mut Contract) -> Result<()> {
        // Sort fields by size for optimal packing (largest first)
        contract.fields.sort_by(|a, b| {
            let size_a = self.get_type_storage_size(&a.type_annotation);
            let size_b = self.get_type_storage_size(&b.type_annotation);
            size_b.cmp(&size_a) // Descending order
        });
        
        // Group small types together to fit in single storage slots
        self.pack_small_fields(&mut contract.fields)?;
        
        Ok(())
    }

    /// Optimize struct storage layout
    fn optimize_struct_storage(&self, struct_def: &mut Struct) -> Result<()> {
        // Sort fields by size for optimal packing
        struct_def.fields.sort_by(|a, b| {
            let size_a = self.get_type_storage_size(&a.type_annotation);
            let size_b = self.get_type_storage_size(&b.type_annotation);
            size_b.cmp(&size_a)
        });
        
        Ok(())
    }

    /// Get storage size in bytes for a type
    fn get_type_storage_size(&self, type_annotation: &Type) -> usize {
        match type_annotation {
            Type::Bool | Type::U8 | Type::I8 => 1,
            Type::U16 | Type::I16 => 2,
            Type::U32 | Type::I32 | Type::F32 => 4,
            Type::U64 | Type::I64 | Type::F64 => 8,
            Type::U128 | Type::I128 => 16,
            Type::U256 | Type::I256 => 32,
            Type::Address => 20,
            Type::String => 32, // Dynamic, but reserve slot
            Type::Array { .. } => 32, // Dynamic, but reserve slot
            Type::Vector { .. } => 32, // Dynamic, but reserve slot
            _ => 32, // Default to 32 bytes for complex types
        }
    }

    /// Pack small fields together to optimize storage slots
    fn pack_small_fields(&self, fields: &mut Vec<Field>) -> Result<()> {
        let mut packed_fields = Vec::new();
        let mut current_slot_size = 0;
        let slot_size = 32; // EVM storage slot size
        
        for field in fields.iter() {
            let field_size = self.get_type_storage_size(&field.type_annotation);
            
            if current_slot_size + field_size <= slot_size {
                // Fits in current slot
                current_slot_size += field_size;
            } else {
                // Start new slot
                current_slot_size = field_size;
            }
            
            packed_fields.push(field.clone());
        }
        
        *fields = packed_fields;
        Ok(())
    }
    
    /// Optimize function calls for gas efficiency
    fn optimize_function_calls(&self, _ast: &mut SourceFile) -> Result<()> {
        // TODO: Implement function call optimization
        // - Inline small functions
        // - Optimize parameter passing
        // - Remove unnecessary function calls
        Ok(())
    }
    
    /// Optimize loops for gas efficiency
    fn optimize_loops(&self, _ast: &mut SourceFile) -> Result<()> {
        // TODO: Implement loop optimization
        // - Loop unrolling for small loops
        // - Strength reduction
        // - Loop invariant code motion
        Ok(())
    }
}

impl OptimizationPass for GasOptimization {
    fn run(&self, ast: &mut SourceFile) -> Result<()> {
        self.optimize_storage_layout(ast)?;
        self.optimize_function_calls(ast)?;
        self.optimize_loops(ast)?;
        Ok(())
    }
    
    fn name(&self) -> &str {
        "Gas Optimization"
    }
}

/// Peephole optimization for bytecode
pub struct PeepholeOptimization;

impl PeepholeOptimization {
    pub fn new() -> Self {
        Self
    }
    
    fn optimize_instruction_sequence(&self, instructions: &mut Vec<Instruction>) {
        let mut i = 0;
        while i + 1 < instructions.len() {
            let optimized = match (&instructions[i], &instructions[i + 1]) {
                // Push followed by Pop -> remove both
                (Instruction::Push(_), Instruction::Pop) => {
                    instructions.drain(i..i + 2);
                    continue;
                }
                // Load followed by Store to same location -> remove both if no side effects
                (Instruction::Load(a), Instruction::Store(b)) if a == b => {
                    instructions.drain(i..i + 2);
                    continue;
                }
                // Duplicate optimizations
                (Instruction::Dup, Instruction::Pop) => {
                    instructions.drain(i..i + 2);
                    continue;
                }
                _ => false,
            };
            
            if !optimized {
                i += 1;
            }
        }
    }
}

impl BytecodeOptimizationPass for PeepholeOptimization {
    fn run(&self, bytecode: &mut Bytecode) -> Result<()> {
        self.optimize_instruction_sequence(&mut bytecode.instructions);
        
        // Optimize contract functions
        for contract in bytecode.contracts.values_mut() {
            self.optimize_instruction_sequence(&mut contract.constructor);
            for function_instructions in contract.functions.values_mut() {
                self.optimize_instruction_sequence(function_instructions);
            }
        }
        
        Ok(())
    }
    
    fn name(&self) -> &str {
        "Peephole Optimization"
    }
}

/// Redundant instruction elimination
pub struct RedundantInstructionElimination;

impl RedundantInstructionElimination {
    pub fn new() -> Self {
        Self
    }
    
    fn eliminate_redundant_instructions(&self, instructions: &mut Vec<Instruction>) {
        let mut i = 0;
        while i < instructions.len() {
            let should_remove = match &instructions[i] {
                // Remove consecutive duplicate pushes of the same value
                Instruction::Push(val1) => {
                    if i + 1 < instructions.len() {
                        if let Instruction::Push(val2) = &instructions[i + 1] {
                            if val1 == val2 {
                                // Replace with Push + Dup
                                instructions[i + 1] = Instruction::Dup;
                                false
                            } else {
                                false
                            }
                        } else {
                            false
                        }
                    } else {
                        false
                    }
                }
                // Remove unreachable code after Return
                Instruction::Return => {
                    // Remove instructions until next label or end
                    let j = i + 1;
                    while j < instructions.len() {
                        match &instructions[j] {
                            Instruction::Jump(_) | Instruction::JumpIf(_) | Instruction::JumpIfNot(_) => break,
                            _ => {
                                instructions.remove(j);
                            }
                        }
                    }
                    false
                }
                _ => false,
            };
            
            if should_remove {
                instructions.remove(i);
            } else {
                i += 1;
            }
        }
    }
}

impl BytecodeOptimizationPass for RedundantInstructionElimination {
    fn run(&self, bytecode: &mut Bytecode) -> Result<()> {
        self.eliminate_redundant_instructions(&mut bytecode.instructions);
        
        // Optimize contract functions
        for contract in bytecode.contracts.values_mut() {
            self.eliminate_redundant_instructions(&mut contract.constructor);
            for function_instructions in contract.functions.values_mut() {
                self.eliminate_redundant_instructions(function_instructions);
            }
        }
        
        Ok(())
    }
    
    fn name(&self) -> &str {
        "Redundant Instruction Elimination"
    }
}

#[cfg(test)]
mod tests {
    use super::*;
    use crate::lexer::Lexer;
    use crate::parser::Parser;
    use crate::codegen::Value;
    use std::collections::HashMap;
    
    fn parse_source(source: &str) -> Result<SourceFile> {
        let mut lexer = Lexer::new(source, "test.aug");
        let tokens = lexer.tokenize()?;
        let mut parser = Parser::new(tokens);
        parser.parse()
    }
    
    #[test]
    fn test_constant_folding() {
        let source = r#"
            fn test() -> u32 {
                return 2 + 3 * 4;
            }
        "#;
        
        let mut ast = parse_source(source).unwrap();
        let optimizer = ConstantFolding::new();
        optimizer.run(&mut ast).unwrap();
        
        // The expression should be folded to a constant
        // This is a basic test - in practice, you'd check the AST structure
    }
    
    #[test]
    fn test_dead_code_elimination() {
        let source = r#"
            fn used_function() -> u32 {
                return 42;
            }
            
            fn unused_function() -> u32 {
                return 0;
            }
            
            fn main() {
                let x = used_function();
            }
        "#;
        
        let mut ast = parse_source(source).unwrap();
        let optimizer = DeadCodeElimination::new();
        optimizer.run(&mut ast).unwrap();
        
        // unused_function should be removed
        assert_eq!(ast.items.len(), 2); // main and used_function
    }
    
    #[test]
    fn test_peephole_optimization() {
        let mut bytecode = Bytecode {
            instructions: vec![
                Instruction::Push(Value::U32(42)),
                Instruction::Pop,
                Instruction::Load(0),
                Instruction::Store(0),
            ],
            constants: Vec::new(),
            functions: HashMap::new(),
            contracts: HashMap::new(),
        };
        
        let optimizer = PeepholeOptimization::new();
        optimizer.run(&mut bytecode).unwrap();
        
        // Both instruction pairs should be eliminated
        assert_eq!(bytecode.instructions.len(), 0);
    }
}